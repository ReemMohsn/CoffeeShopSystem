@using System.Linq;
@* Inject Antiforgery service to generate the token *@
@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Antiforgery

@{
    // Generate Antiforgery token for the form/JS
    var requestToken = Antiforgery.GetAndStoreTokens(Context).RequestToken;
}

@section Links{
    <title>@ViewBag.Product.NameProduct</title>
    <link rel="stylesheet" href="~/css/Product Details.css">
    <style>
        .choice-input { opacity: 0; position: absolute; }
        .choice { display: inline-block; padding: 10px 15px; margin: 5px; border: 1px solid #ddd; border-radius: 5px; cursor: pointer; }
        .choice-input:checked + .choice { background-color: #f0f0f0; border-color: #333; }
    </style>
}

@* Add the hidden input field to store the token *@
<input type="hidden" id="RequestVerificationToken" name="__RequestVerificationToken" value="@requestToken" />

<section class="ProductDetails" id="productDetails">
    <div>
        <img src="~/imges/Pattern.png" alt="pattern" class="pattern1">
        <img src="~/imges/Pattern rec.png" alt="pattern" class="pattern2">
        <img src="~/imges/@Url.Content(ViewBag.Product.Picture)" alt="@ViewBag.Product.NameProduct" class="productImge">
    </div>
    <div class="Details">
        <div class="ProductName">
            <p style="font-weight: lighter;">@ViewBag.Product.NameProduct</p>
            @* Corrected heart icon setup for JS interaction *@
            <img src="@Url.Content("~/imges/123.png")" alt="Favorite Status" class="haret favorite-icon"
                 data-id="@ViewBag.Product.IdProduct"
                 data-is-favorite="false"
                 style="cursor:pointer;"
                 title="Add to Favorites">
        </div>
        <div class="Evaluate">
            <p>
                <img src="~/imges/star.png" alt="star" class="star"> @ViewBag.Product.AverageRating.ToString("0.0")
            </p>
        </div>
        <div class="description">
            <p class="subtital">About</p>
            <p class="AboutDescription">@ViewBag.Product.About</p>
        </div>

        @* Form for adding sweets to the basket *@
        <form asp-controller="Products" asp-action="AddSweetToBasket" method="post">
            @* Token for form submission (if AddSweetToBasket requires it) *@
            @* <input type="hidden" name="__RequestVerificationToken" value="@requestToken" /> *@
            <input type="hidden" name="productId" value="@ViewBag.Product.IdProduct" />

            <div class="OrderDetails">
                <div class="Order">
                    <p class="subtital">Sizes</p>
                    <div class="row">
                        @if (ViewBag.Product.Prices != null && ViewBag.Product.Prices.Count > 0)
                        {
                            @foreach (var size in ViewBag.Product.Prices)
                            {
                                <input type="radio" name="sizeId" id="size_@size.Key" class="choice-input" value="@size.Key" data-price="@size.Value" required />
                                <label for="size_@size.Key" class="choice">
                                    @(size.Key == 1 ? "S" : size.Key == 2 ? "M" : size.Key == 3 ? "L" : "Unknown size")
                                    - $@size.Value.ToString("0.00")
                                </label>
                            }
                        }
                        else { <p>No sizes available for this product.</p> }
                    </div>
                </div>
                <hr />
                <div class="Order">
                    <p class="subtital">Flavours (optional)</p>
                    <div class="row">
                        @if (ViewBag.Flavour != null && ViewBag.Flavour.Count > 0)
                        {
                            @foreach (var flavour in ViewBag.Flavour)
                            {
                                <input type="radio" name="flavour" id="flavour_@flavour.Id" class="choice-input" value="@flavour.Id" data-price="@flavour.Price" />
                                <label for="flavour_@flavour.Id" class="choice">
                                    @flavour.Name - $@flavour.Price.ToString("0.00")
                                </label>
                            }
                        }
                        else { <p>No flavour options available.</p> }
                    </div>
                </div>
            </div>

            <div class="ProductsContener"> @* Note: Class name might be confusing here *@
                <button type="submit" class="form-add-to-cart-button addition AddIcon">Add to cart</button>
                <p class="price">$@ViewBag.Product.MinPrice.ToString("0.00")</p> @* Display initial min price *@
            </div>
        </form>
    </div>
</section>

<section class="Menu" id="menue">
    <div class="SubHeader">
        <h1 style="font-weight: lighter;">You may also like</h1>
    </div>
    <div class="Menurow ProductsContener">
        @if (ViewBag.RelatedProducts != null)
        {
            @foreach (var product in ViewBag.RelatedProducts)
            {
                 // Determine action based on related product category
                 var relatedAction = "ProductDetails"; // Default
                 if (product.IdCategory == 1 || product.IdCategory == 2) { relatedAction = "ProductDetailsDrinks"; }
                 else if (product.IdCategory == 3) { relatedAction = "ProductDetailsSweets"; }

                 <div class="product">
                     <a href="@Url.Action(relatedAction, "Products", new { id = product.IdProduct })">
                         <img src="~/imges/@Url.Content(product.Picture ?? "~/imges/placeholder.png")" alt="@product.NameProduct" class="productImge">
                     </a>
                     <div class="productDetails">
                         <div class="ProductName"> <p><b>@product.NameProduct</b></p> </div>
                         <div class="Evaluate"> <p>@product.AverageRating.ToString("0.0") <img src="~/imges/star.png" alt="star" class="star"></p> </div>
                         <div class="details">
                             @* Consider making these dynamic if possible *@
                             <p class="Volume">without chocolate</p>
                             <p class="Volume">Volume 100 ml</p>
                         </div>
                         <div class="PriceAdd">
                             <p class="price1">$@product.MinPrice.ToString("0.00")</p>
                             <a href="#" class="add-to-cart-related" data-id="@product.IdProduct" title="Add to Cart">
                                 <img src="~/imges/add.png" alt="AddIcon" class="AddIcon addition">
                             </a>
                         </div>
                     </div>
                 </div>
            }
        }
        else { <p>No related products found.</p> }
    </div>
</section>

@section Scripts
{
    <script>
    document.addEventListener('DOMContentLoaded', function () {

        // --- Antiforgery Token ---
        const verificationTokenInput = document.getElementById('RequestVerificationToken');
        const verificationToken = verificationTokenInput?.value; // Read token value
        if (!verificationToken) {
            console.error('AntiForgery Token not found! Favorite toggle will fail.');
            document.querySelectorAll('.favorite-icon').forEach(icon => icon.style.display = 'none');
        }

        // --- Favorite Toggle Logic ---
        const favoriteIcons = document.querySelectorAll('.favorite-icon'); // Should only be one on details page

        async function updateFavoriteIcon(icon) {
            const productId = icon.dataset.id;
            if (!productId) return;

            try {
                const response = await fetch(`/Favorit/CheckFavorite?productId=${productId}`);
                if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                const data = await response.json();

                if (data.isFavorite) {
                    icon.src = '/imges/galeb.png'; // Filled heart
                    icon.dataset.isFavorite = 'true';
                    icon.title = 'Remove from Favorites';
                } else {
                    icon.src = '/imges/123.png'; // Empty heart
                    icon.dataset.isFavorite = 'false';
                    icon.title = 'Add to Favorites';
                }
            } catch (error) {
                console.error('Error checking favorite status:', error);
            }
        }

        favoriteIcons.forEach(icon => {
            // Initial check on page load
            updateFavoriteIcon(icon);

            // Click event listener
            icon.addEventListener('click', async function (e) {
                e.preventDefault();
                const productId = this.dataset.id;

                if (!verificationToken) {
                     alert('Error: Missing security token. Cannot update favorites.');
                     return;
                }
                 if (!productId) {
                     alert('Error: Missing product ID. Cannot update favorites.');
                     return;
                }

                this.style.opacity = '0.5'; // Visual feedback

                try {
                    // Fetch call includes Token Header and JSON body
                    const response = await fetch('/Favorit/ToggleFavorite', {
                        method: 'POST',
                        headers: {
                            'RequestVerificationToken': verificationToken,
                            'Content-Type': 'application/json',
                            'Accept': 'application/json'
                        },
                        body: JSON.stringify({ productId: parseInt(productId) })
                    });

                    this.style.opacity = '1'; // Reset visual feedback

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ message: `Server error: ${response.status}` }));
                        throw new Error(errorData.message || `Failed to update favorite status.`);
                    }

                    const result = await response.json();

                    if (result.success) {
                        // Update icon based on the NEW status from server
                        if (result.isFavorite) {
                            this.src = '/imges/galeb.png';
                            this.dataset.isFavorite = 'true';
                            this.title = 'Remove from Favorites';
                        } else {
                            this.src = '/imges/123.png';
                            this.dataset.isFavorite = 'false';
                            this.title = 'Add to Favorites';
                        }
                        console.log(result.message); // Log success message
                    } else {
                         alert(result.message || 'Failed to update favorite status.');
                         if (result.redirectToLogin) {
                             window.location.href = '/SignInUp/SignIn';
                         }
                    }
                } catch (error) {
                    console.error('Error toggling favorite:', error);
                    alert('Error: ' + error.message);
                    this.style.opacity = '1'; // Reset visual feedback on error
                }
            });
        });

        // --- Price Update Logic for Sweets ---
        const sizeRadioButtons = document.querySelectorAll('input[name="sizeId"]');
        const flavourRadioButtons = document.querySelectorAll('input[name="flavour"]');
        const priceDisplayElement = document.querySelector('.ProductsContener .price'); // Check selector
        const initialMinPrice = parseFloat(@Html.Raw(Json.Serialize(ViewBag.Product.MinPrice))); // Get initial price

        function updatePriceDisplay() {
            let selectedSizePrice = 0;
            let selectedFlavourPrice = 0; // Changed variable name

            const checkedSizeRadioButton = document.querySelector('input[name="sizeId"]:checked');
            const checkedFlavourRadioButton = document.querySelector('input[name="flavour"]:checked'); // Changed variable name

            // Use initial min price if no size is selected yet
            selectedSizePrice = checkedSizeRadioButton ? parseFloat(checkedSizeRadioButton.getAttribute('data-price')) : initialMinPrice;

            if (checkedFlavourRadioButton) {
                selectedFlavourPrice = parseFloat(checkedFlavourRadioButton.getAttribute('data-price')); // Changed variable name
            }

            if (priceDisplayElement) {
                // Only add flavour price if a size IS selected
                const totalPrice = checkedSizeRadioButton
                                    ? selectedSizePrice + selectedFlavourPrice // Changed variable name
                                    : selectedSizePrice; // Show min price if no size selected
                priceDisplayElement.textContent = `$${totalPrice.toFixed(2)}`;
            }
        }

        sizeRadioButtons.forEach(radio => radio.addEventListener('change', updatePriceDisplay));
        flavourRadioButtons.forEach(radio => radio.addEventListener('change', updatePriceDisplay)); // Changed variable name

        // Initial price update on load
        updatePriceDisplay();


        // --- Related Products AddToCart Logic ---
        document.querySelectorAll('.add-to-cart-related').forEach(button => {
            button.addEventListener('click', async function (e) {
                e.preventDefault();
                const productId = this.getAttribute('data-id');
                const verificationTokenForRelated = verificationToken; // Use the same token

                 if (!verificationTokenForRelated) {
                     alert('Error: Missing security token. Cannot add to cart.');
                     return;
                 }
                 if (!productId) {
                     alert('Error: Missing product ID. Cannot add to cart.');
                     return;
                 }

                this.style.opacity = '0.5';

                try {
                    // Assuming AddToCartSimple expects form data and validates token
                    const response = await fetch('/Products/AddToCartSimple', {
                        method: 'POST',
                        headers: {
                            'RequestVerificationToken': verificationTokenForRelated,
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `productId=${encodeURIComponent(productId)}`
                    });

                     this.style.opacity = '1';

                    if (!response.ok) {
                         const errorData = await response.json().catch(() => ({ message: `Server error: ${response.status}` }));
                         throw new Error(errorData.error || errorData.message || `Failed to add item.`);
                    }

                    const result = await response.json();
                    if (result.success) {
                        alert(result.message);
                    } else {
                        alert(result.error || result.message || 'Could not add item to cart.');
                         if (result.redirectToLogin) {
                             window.location.href = '/SignInUp/SignIn';
                         }
                    }
                } catch (error) {
                    console.error('Error adding related item to cart:', error);
                    alert('Error: ' + error.message);
                    this.style.opacity = '1';
                }
            });
        });

        // --- TempData Messages ---
        const loginErrorMessage = @Html.Raw(Json.Serialize(TempData["ErrorMessage"]));
        if (loginErrorMessage) { alert(loginErrorMessage); }
        const successMessage = @Html.Raw(Json.Serialize(TempData["SuccessMessage"]));
        if (successMessage) { alert(successMessage); }

    });
    </script>
}
